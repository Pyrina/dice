/* Copyright Jos Bodewes 2014 - 2015 - Keep on rolling dice - The case.
Boost Software License - Version 1.0 - August 17th, 2003

Permission is hereby granted, free of charge, to any person or organization
obtaining a copy of the software and accompanying documentation covered by
this license (the "Software") to use, reproduce, display, distribute,
execute, and transmit the Software, and to prepare derivative works of the
Software, and to permit third-parties to whom the Software is furnished to
do so, all subject to the following:

The copyright notices in the Software and this entire statement, including
the above license grant, this restriction and the following disclaimer,
must be included in all copies of the Software, in whole or in part, and
all derivative works of the Software, unless such copies or derivative
works are solely in the form of machine-executable object code generated by
a source language processor.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.
*/

/*
This file contains all designs for the dice case. Since all sides are basically the same, 
the easiest way to get a different side, is by setting a variable value: print.
The values in this list indicate which side - or sides - is shown in the render area.

To save each side as a 3D model (eg STL), set print to <1, 2, 3>, press F6 and save as STL.
Values 4 to 7 are for testing the design, to check if all connector parts are in the correct
position and properly alligned. By changing the value of assembleOffset, you can change the
distance between the sides.

Value 8 is to only render the switch. This component was a little hard to design, and by only 
creating a STL with just that part, created a small object to print to save time and money.

This file works with OpenSCAD 2015.01 and newer.

	1 = one side
	2 = top
	2 = bottom
    4 = all sides as cube, no top/bottom
	5 = all
	6 = top and two sides
	7 = bottom and two sides
	8 = top cut-out --> switch only
*/

print = 1;
pcbShow = 0;
showConnectorScrew = 0;
assembleOffset = 0; //15.0 * $t;  // this is to animate the assembly of the case

pcbWidth = 2.3 * 25.4;
pcbHeight = 2.3 * 25.4;

pcbOffset = 16;

/** text ************************/
textSize = 5.5;

/** switch **********************/
switchCounterSink = 3.0;
switchTopLength = 20.0;
switchLength = 12.0;
switchInnerLength = 8.0;
switchInnerWidth = 5.0;
switchWidth = 6.0;
switchScrewDist = 7.5;		// the distance from the centre of the switch to the hart of the hole
switchScrewSize = 2.0;		// M2.0
switchHousingHeight = 4;
switchSlideInHeight = switchHousingHeight - 0.5;

/** outer dimensions **********************/
sideWidth = pcbWidth + 2 * pcbOffset;
sideHeight = pcbHeight + 2 * pcbOffset;
sideDepth = 2;

/** led **********************/
ledDepth = sideDepth - 1.1;
ledWidth = 8;

/** screw **********************/
screwSize = 3.3;
screwCounterSink = 3.0;

/** spacer **********************/
spacerHeight = 7 + sideDepth;
spacerAddHeightTop = 4;

/** connector **********************/
connectorTopBottomLength = 7;
connectorWidth = 7; //10;
connectorLength = (sideWidth - 2 * sideDepth) / 4;
connectorLengthShort = 7;
connectorLengthMiddle = (sideWidth - (2 * sideDepth) - (2 * connectorLengthShort)  - (2 * connectorTopBottomLength) - connectorLength) / 2;
connectorScrewSize = 3.1;
connectorScrewTopSize = 6;
// connector screw: https://www.conrad.nl/nl/toolcraft-verzonken-schroeven-m3-40-mm-kruiskop-philips-din-965-staal-galvanisch-verzinkt-1000-stuks-134499.html
connectorScrewLength = 40;

/** constants - better not change these values! **********************/
CONNECTORS_SIDE   = 1;
CONNECTORS_TOP    = 2;
CONNECTORS_BOTTOM = 4;

SIDE_LEFT = 1;
SIDE_RIGHT = 2;

SWITCH_HOLE = 1;
SWITCH_SPACER = 2;

/* *****************************************************************************************
/*
/* PCB
/*
/* This is just a test if the PCB will fit in the case.
/* To show the PCB set the value of pcbShow to 1.
/* Make sure to set it to 0 before creating the rendered model.
/* ****************************************************************************************/
module pcb(addHeightTop) {
	translate([pcbOffset, pcbOffset, spacerHeight + sideDepth + addHeightTop])
	color ("red") 
		cube([pcbWidth, pcbHeight, 2]);
}


/* *****************************************************************************************
/*
/* Thread
/*
/* This function is to add a thread to a spacer, so it will hold a screw.
/* Arguments:
/*  - h: height in mm
/*  - r: radius of the screw
/* ****************************************************************************************/
module thread(h, r) {
	s = 0.5; // 0.5 mm is the smallest value that is actually printed

	translate([r - s, 0, 0])
		cube([s, s, h]);

	translate([-r, 0, 0])
		cube([s, s, h]);

	translate([-s / 2, r - s, 0])
		cube([s, s, h]);

	translate([-s / 2, -r, 0])
		cube([s, s, h]);
}


/* *****************************************************************************************
/*
/* the on/off switch
/*
/* These modules draw the on/off switch
/* ****************************************************************************************/
module theSwitchSpacer() {
    extraMArginTop = 4;

	// spacer
	translate([  -(switchTopLength + 1) / 2
			  , -(((switchWidth + 1) - switchInnerWidth) / 2)
			  , sideDepth - 0.5]) {
		difference() {
			// main switch spacer
            // height increased with 1 mm to make sure it is trong enough
			cube([  switchTopLength + 1
                              , switchWidth + 1
                              , switchCounterSink + switchHousingHeight + 1]);
	
			// switch counter sink
			translate([0.5, 0.5, switchCounterSink - 0.5])
				cube([switchTopLength, switchWidth , switchCounterSink]);

			// switch slide-in insert 
			// hole
			translate([   ((switchTopLength - 0.5) / 3) - (extraMArginTop / 2)
                                    , -(switchWidth -2)
                                    , 3])
				cube([  switchInnerLength + extraMArginTop
                                      , switchInnerLength + 2
                                      , switchCounterSink + switchHousingHeight + 1]);
			// slide in
			translate([0.5, -0.5, switchCounterSink + 0])
				cube([switchTopLength , switchWidth , switchSlideInHeight]);
		}
	}
}


module theSwitchScrewHole(pos) {
//	posFromCenter = 
	translate([pos, switchInnerWidth / 2, sideDepth]) {
		difference() {
			cylinder(  h = switchHousingHeight * 2
				 , r = switchScrewSize / 2
				 , $fn = 100);

			thread(switchHousingHeight * 2, switchScrewSize / 2);
		}
	}
}

module theSwitchHole() {

		// the counter sink
		// switch hole
		translate([-switchInnerLength / 2, 0, 0])
			cube([switchInnerLength, switchInnerWidth, switchCounterSink * 2]);
		
		// the screw holes
		theSwitchScrewHole(-switchScrewDist);
		theSwitchScrewHole(switchScrewDist);

}

module theSwitch(switchType) {
	translate([   sideWidth - ((sideWidth - switchInnerLength) / 3) - 5
			 , sideHeight - sideDepth - (connectorWidth / 2) - (switchInnerWidth / 2)
			 , -0.1]) {
		if(switchType == SWITCH_HOLE) {
			theSwitchHole();
		}
		else {
			theSwitchSpacer();
		}
	}
}

/* *****************************************************************************************
/*
/* Connectors - to connect the sides and the top and bottom to make the dice
/*
/* These modules create the connectors, depending on the side being rendered.
/* ****************************************************************************************/
module connectorHoleTopBottom(screwSize) {

	translate([-0.1, connectorWidth / 2, connectorWidth / 2])
		rotate([0, 90, 0])
			cylinder(  h = (sideDepth * 0.7) + connectorTopBottomLength
					, r = screwSize / 2
					, $fn = 100);
}

module connectorHole(screwSize, side) {
	sideSwitch = side == SIDE_RIGHT ? -connectorWidth - 1 : 1.4;

	translate([-1, connectorWidth / 2, connectorWidth / 2]) {
		rotate([0, 90, 0])
			cylinder(  h = sideWidth
				   , r = screwSize / 2
				   , $fn = 100);
	}
}

module connectorCounterSink() {
	translate([connectorTopBottomLength, connectorWidth / 2, connectorWidth / 2])
		rotate([0, 90, 0])
			cylinder(  h = screwCounterSink
				    , r = connectorScrewTopSize / 2
				    , $fn = 100);
}

module sideConnectors() {
        threadConnectorScrewSize = connectorScrewSize + 0.2;
    
	// left
	// front
	translate([sideDepth + connectorTopBottomLength, sideDepth, sideDepth])
		difference() {
			cube([connectorLengthShort, connectorWidth, connectorWidth]);
			connectorHole(connectorScrewSize, SIDE_LEFT);
		}

	// middle --> this is the one with the thread for the screws
	translate([(sideWidth - connectorLength) / 2, sideDepth, sideDepth]) {
		difference() {
			cube([connectorLength, connectorWidth, connectorWidth]);
			connectorHole(threadConnectorScrewSize, SIDE_LEFT);
		}

		translate([0, connectorWidth / 2, connectorWidth / 2])
			rotate([0, 90, 0])
				thread(connectorLength, threadConnectorScrewSize / 2);
	}

	// back
	translate([sideWidth - sideDepth - connectorTopBottomLength - connectorLengthShort, sideDepth, sideDepth])
		difference() {
			cube([connectorLengthShort, connectorWidth, connectorWidth]);
			connectorHole(connectorScrewSize, SIDE_LEFT);
		}

	// right
	// front
	translate([sideDepth + connectorTopBottomLength + connectorLengthShort, sideHeight - connectorWidth - sideDepth, sideDepth])
		difference() {
			cube([connectorLengthMiddle, connectorWidth, connectorWidth]);
			connectorHole(connectorScrewSize, SIDE_RIGHT);
		}
	// back
	translate([   sideWidth - sideDepth - connectorTopBottomLength - connectorLengthShort - connectorLengthMiddle
			, sideHeight - connectorWidth - sideDepth
			, sideDepth])
		difference() {
			cube([connectorLengthMiddle, connectorWidth, connectorWidth]);
			connectorHole(connectorScrewSize, SIDE_RIGHT);
		}
}

module sideConnectorsCorrector() {
	mirror([1, 0, 0])
	rotate([0, 0, 90]) {
		// left
		translate([sideDepth + 3 * connectorLength + 1, sideDepth, sideDepth ])
			difference() {
				cube([connectorLength, connectorWidth, connectorWidth]);
				connectorHole(connectorScrewSize, SIDE_LEFT);
			}

		// right
		translate([sideDepth - 1, sideHeight - connectorWidth - sideDepth, sideDepth])
			difference() {
				cube([connectorLength, connectorWidth, connectorWidth]);
				connectorHole(connectorScrewSize, SIDE_RIGHT);
			}
	}
}

module connectorHoleOrCube(addConnectors, drillHole, screwSize) {
	if(drillHole == 1) {
		if(addConnectors == CONNECTORS_SIDE)
			connectorHole(screwSize);
		else
			connectorHoleTopBottom(screwSize);

		if(addConnectors == CONNECTORS_TOP || addConnectors == CONNECTORS_BOTTOM)
			connectorCounterSink();
	}
	else {
		cube([connectorTopBottomLength, connectorWidth, connectorWidth]);

		translate([0, connectorWidth / 2, connectorWidth / 2])
			rotate([0, 90, 0])
				cylinder(  h = connectorTopBottomLength
					    , r1 = connectorWidth / 2
					    , r2 = connectorWidth
					    , $fn = 100);
	}
}

module topBottomConnectors(addConnectors, drillHole) {
	screwSize = connectorScrewSize;
	moveZ = connectorTopBottomLength + sideDepth - 0.01;

	translate([sideDepth, sideDepth, moveZ])
		rotate([0, 90, 0])
			connectorHoleOrCube(addConnectors, drillHole, screwSize);

	translate([ sideDepth
			 , sideHeight - sideDepth - connectorWidth
			 , moveZ])
		rotate([0, 90, 0])
			connectorHoleOrCube(addConnectors, drillHole, screwSize);

	translate([sideHeight - sideDepth - connectorWidth
			 , sideDepth
			 , moveZ])
		rotate([0, 90, 0])
			connectorHoleOrCube(addConnectors, drillHole, screwSize);

	translate([sideHeight - sideDepth - connectorWidth
			 , sideHeight - sideDepth - connectorWidth
			 , moveZ])
		rotate([0, 90, 0])
			connectorHoleOrCube(addConnectors, drillHole, screwSize);

}

module TEST_connectorScrew() {
	translate([-1, (connectorWidth / 2) + sideDepth, (connectorWidth / 2) + sideDepth]) 
		rotate([0, 90, 0])
			cylinder(  h = connectorScrewLength
				   , r = screwSize / 2
				   , $fn = 100);

}

module connectors(addConnectors) {
	if(addConnectors == CONNECTORS_SIDE) {
		mirror()
			rotate([0, 0, 90]) {
				sideConnectors();

				if(showConnectorScrew == 1)
					TEST_connectorScrew();
			}
	}
	else {
		topBottomConnectors(addConnectors, 0);
	}
}

/* *****************************************************************************************
/*
/* The base of each side, including the sloped edges.
/*
/* ****************************************************************************************/
module base_plate(addConnectors) {

	difference() 
	{
		cube([sideWidth, sideHeight, sideDepth]);

		//slice the sides
		translate([-1, -1, -1])
			rotate([45, 0, 0])
				cube([sideWidth + 2, 10, 10]);

		translate([-1, sideHeight + 1, -1])
			rotate([45, 0, 0])
				cube([sideWidth + 2, 10, 10]);

		translate([-1, -1, -1])
			rotate([0, -45, 0])
				cube([10, sideHeight + 2, 10]);

		translate([sideWidth + 1, -1, -1])
			rotate([0, -45, 0])
				cube([10, sideHeight + 2, 10]);
	}

	connectors(addConnectors);
}

module base_plate_corrector() {
	translate([-sideDepth, 0, sideDepth - 0.1])
	cube([sideDepth * 2, sideHeight, connectorTopBottomLength * 2]);

	translate([0, -sideDepth, sideDepth - 0.1])
	cube([sideWidth, sideDepth * 2, connectorTopBottomLength * 2]);

	translate([sideWidth - sideDepth, 0, sideDepth - 0.1])
	cube([sideDepth * 2, sideHeight, connectorTopBottomLength * 2]);

	translate([0, sideHeight - sideDepth, sideDepth - 0.1])
	cube([sideWidth, sideDepth * 2, connectorTopBottomLength * 2]);
}

/* *****************************************************************************************
/*
/* the spaces to hold the PCB
/*
/* ****************************************************************************************/
module spacer_base_main(addHeightTop) {
	spacerWidth = screwSize * 1.6;

	// the main screw spacer
	cylinder(h = spacerHeight + addHeightTop, r = spacerWidth, $fn = 100);

	// the trapezoid base to give the spacer more support
	cylinder(h = spacerHeight / 2, 
			r1 = spacerWidth * 1.7, 
			r2 = spacerWidth, 
			$fn = 100);
}

module spacer_base(x, y, addHeightTop) {
	x_mm = (x * 25.4) + pcbOffset;
	y_mm = (y * 25.4) + pcbOffset;

	translate([x_mm, y_mm, sideDepth]) {
		difference() {
			spacer_base_main(addHeightTop);

			cylinder(h = (spacerHeight + addHeightTop) * 2, r = screwSize / 2.1, $fn = 100);
		}

		thread(spacerHeight + addHeightTop, screwSize / 2.1);
	}
}

module nameText(x, y, theText) {
        translate([x, y, sideDepth - 0.5])
            linear_extrude(height = textSize, convexity = 3)
                text(theText, 
                     size = textSize * 22 / 30,
                     font = "Tahoma:style=Bold",
                     halign = "center",
                     valign = "center");
}

/* *****************************************************************************************
/*
/* the hole in one side of the base plate so the light of the led can shine through 
/*
/* ****************************************************************************************/
module ledHole(x, y, addHeightTop) {
	x_mm = (x * 25.4) + pcbOffset;
	y_mm = (y * 25.4) + pcbOffset;

	translate([x_mm, y_mm, sideDepth - ledDepth]) {
		cylinder(h = (spacerHeight + addHeightTop) * 2, r = ledWidth / 2, $fn = 100);
	}
}


/* *****************************************************************************************
/*
/* assembler to construct one side, no hole is the base plate
/*
/* ****************************************************************************************/
module oneSide(color, addConnectors) {
	addHeightTop = addConnectors == CONNECTORS_TOP ? spacerAddHeightTop : 0;
        sideText = addConnectors == CONNECTORS_TOP ? "top" :
                   addConnectors == CONNECTORS_BOTTOM ? "bottom" : "side";

	color(color)
        difference()  {
            base_plate(addConnectors);

            base_plate_corrector();
            nameText(sideWidth / 2, pcbOffset + 18, "Pyrina dice v1.0");
            nameText(sideWidth / 2, pcbOffset + 13, "February 9, 2015");
            nameText(sideWidth / 2, pcbOffset + 8, sideText);
		}

	// the x - y values are in inches!
	spacer_base(0.1, 0.1, addHeightTop);
	spacer_base(0.1, 2.2, addHeightTop);
	spacer_base(2.2, 2.2, addHeightTop);
	spacer_base(2.2, 0.1, addHeightTop);

	// spacer for the switch
	if(addConnectors == CONNECTORS_TOP)
		theSwitch(SWITCH_SPACER);
}

/* *****************************************************************************************
/*
/* Main side assembler
/*
/* ****************************************************************************************/
module mainSide(color, addConnectors) {
	addHeightTop = addConnectors == CONNECTORS_TOP ? spacerAddHeightTop : 0;

	if(pcbShow == 1)
		pcb(addHeightTop);

	difference() {
		oneSide(color, addConnectors);

		ledHole(0.3, 0.2, addHeightTop);
		ledHole(0.3, 1.1, addHeightTop);
		ledHole(0.3, 2.1, addHeightTop);

		ledHole(1.15, 2.1, addHeightTop);
		ledHole(1.15, 1.1, addHeightTop);

		ledHole(2.0, 2.1, addHeightTop);
		ledHole(2.0, 1.1, addHeightTop);
		ledHole(2.0, 0.2, addHeightTop);

		if(addConnectors == CONNECTORS_TOP)
			theSwitch(SWITCH_HOLE);

		if(addConnectors == CONNECTORS_TOP || addConnectors == CONNECTORS_BOTTOM) 
			topBottomConnectors(addConnectors, 1);
	}
}

/* *****************************************************************************************
/*
/* Show the four sides 
/*
/* ****************************************************************************************/
module fourSides() {

	// bottom
	mainSide("green", CONNECTORS_SIDE);

	// left
	translate([sideWidth, 0, 0])
		rotate([0, -90, 0]) 
			mainSide("Magenta", CONNECTORS_SIDE);

	// right
	translate([0, 0, sideWidth])
		rotate([0, 90, 0]) 
			mainSide("yellow", CONNECTORS_SIDE);

	// top
	translate([sideWidth, 0, sideWidth])
		rotate([0, 180, 0])
			mainSide("blue", CONNECTORS_SIDE);
}

/* *****************************************************************************************
/*
/* Show the top side
/*
/* ****************************************************************************************/
module sideTop() {
	mainSide("tan", CONNECTORS_TOP);
}

/* *****************************************************************************************
/*
/* Show the top side cut-out --> switch
/*
/* ****************************************************************************************/
module sideTopCutOut() {
	translate([-sideWidth, -sideHeight, 0])
	difference() {
		mainSide("tan", CONNECTORS_TOP);

		// most of the part, minus 25 mm
		translate([-1, -1, -1])
			cube([sideWidth * 2, sideHeight - 25, 100]);

		// half of the remaining part, so only the switch and one pcb spacer are left
		translate([0, -1, -1])
			cube([sideWidth / 2, sideHeight * 2, 100]);
	}
}

/* *****************************************************************************************
/*
/* Show the bottom side
/*
/* ****************************************************************************************/
module sideBottom() {
	mainSide("Khaki", CONNECTORS_BOTTOM);
}

/* *****************************************************************************************
/*
/* Show all sides
/*
/* ****************************************************************************************/
module allSides() {
	fourSides();

	translate([0, sideWidth, 0])
		rotate([90, 0, 0]) 
			sideTop();

	translate([sideWidth, 0, 0])
		rotate([90, 0, 180]) 
			sideBottom();
}

/* *****************************************************************************************
/*
/* Show top and one side
/*
/* ****************************************************************************************/
module topAndSides() {
	// bottom
	mainSide("green", CONNECTORS_SIDE);

	// left
	translate([sideWidth + assembleOffset, 0, 0])
		rotate([0, -90, 0]) 
			mainSide("Magenta", CONNECTORS_SIDE);

	translate([0, sideWidth + assembleOffset, 0])
		rotate([90, 0, 0]) 
			sideTop();
}

/* *****************************************************************************************
/*
/* Show bottom and one side
/*
/* ****************************************************************************************/
module bottomAndSides() {
	// bottom
	mainSide("green", CONNECTORS_SIDE);

	// left
	translate([sideWidth + assembleOffset, 0, 0])
		rotate([0, -90, 0]) 
			mainSide("Magenta", CONNECTORS_SIDE);

	translate([0, sideWidth + assembleOffset, 0])
		rotate([90, 0, 0]) 
			sideBottom();
}


/* *****************************************************************************************
/*
/* the main controller
/*
/* ****************************************************************************************/
module main() {
/*
	1 = one side
	2 = top
	2 = bottom
    4 = all sides as cube, no top/bottom
	5 = all
	6 = top and two sides
	7 = bottom and two sides
	8 = top cut-out --> switch only
*/
    if(print == 1)
		mainSide("green", 1);
	else if(print == 2)
		sideTop();
	else if(print == 3)
		sideBottom();
    else if(print == 4)
		fourSides();
	else if(print == 5)
		allSides();
	else if(print == 6)
		topAndSides();
	else if(print == 7)
		bottomAndSides();
	else if(print == 8)
		sideTopCutOut();
}

main();





